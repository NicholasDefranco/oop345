// Name: Nicholas Defranco
// Seneca Student ID: 106732183
// Seneca email: ndefranco@myseneca.ca
// Date of completion: Tuesday, November 5th, 2019
//
// I confirm that the content of this file is created by me,
// 	with the exception of the parts provided to me by my professor.

In this Workshop, I learned how to use a std::vector. The std::vector is a 
type of container template class which is a part of the Standard Template 
Library (more commonly known as an STL) of the C++ standard library. As the 
name suggests, the containers defined in the STL are defined as templates 
which allow code reuse. In general the, the purpose of an STL container is 
to manage elements within the data structure that the specific container 
represents. For example, manages elements allocated off the heap, all of 
which are stored contiguously in memory. Since elements are allocated of the 
heap, it can modify its size, either increasing or decreasing, whenever 
required. Other STL containers also store their elements off the heap however,
this specific container excels at insertion or removal of elements at the 
end of the array of elements. Other STL containers have their own benefits 
and drawbacks. 

(1) Every container class defines a destructor. This includes the vector 
container. Therefore, when an Autoshop object goes out of scope, the vector 
object’s destructor is called. During the destruction of the vector, all 
statically allocated members of the class are deallocated automatically (
including elements of the sequence). However, if the container was managing 
elements of raw pointer type where each element pointed to a resource, the 
pointers themselves will be automatically deallocated (as they are 
statically allocated) but the pointer’s associated resource would not be 
deallocated. The reason the resource is not deallocated is because raw 
pointers (as well as the other built-in types) do not define a destructor 
that will automatically deallocate the resource. In other words it will 
destruct the elements only if they have automatic storage duration.

(2) In the workshop, the createInstance() function, as well as the 
constructor code, threw an exception on the occurrence of an error. The 
client is responsible for reading the error message and taking the 
appropriate action. In this workshop, the client, regardless of the error 
that occurred while reading the file the action was to simply ignore the 
rest of the data in the record. An alternate solution that does not use 
exceptions could be having createInstance() return nullptr on failure. The 
exceptions generated by the constructor as well as the createInstance() 
function itself can be handled internally by the function itself. To 
determine the exact error that occurred, the Car module’s implementation 
file can define a variable of integral type that holds a value that will be 
used to indicate the error that occurred during the last performed operation 
on an object within the Vehicle hierarchy. The Vechicle module can define 
symbolic constants representing what the value of the error number will be 
if that error were to occur. The client can access the value of the error 
number with an external linkage declaration and take appropriate 
action based on its value after calling createInstance(). 

(3) No, the template type for the containers used in this workshop could not 
have been sdds::Vehicle. The reason is that the vehicle class is an abstract 
base class which cannot be instantiated. Therefore, it would be impossible 
to add elements into the container since the elements would not be 
able to be constructed in the first place. Even if the sdds::Vechicle 
class was a concreate class, simply storing instances of 
values of that class will not allow dynamic dispatch(late binding) to occur. 

On the other hand, a template parameter of type sdds::Vehicle * for the 
containers (as used in the workshop) creates a container that manages 
elements where each element is a polymorphic object. The static type (sdds::
Vechicle), only specifies the hierarchy. The dynamic type of each element 
is of any concrete type defined within the hierarchy. Since the amount of 
objects to be created as well as the specific type of each are 
determined at run-time, late-binding must occur as the specific concrete type 
is only known at runtime. A polymorphic object facilitates late-binding by 
calling the correct member function based on it's dynamic type not the 
static type.

Quiz reflection

I got 9/8
